#include "ShaderCache.hpp"

#include "Engine.hpp"
#include "Event/Frame/InitialiseEvent.hpp"
#include "Event/Frame/CleanupEvent.hpp"
#include "Render/Pipeline.hpp"
#include "Render/RenderPass.hpp"
#include "Render/RenderSystem.hpp"
#include "Technique/RenderTechnique.hpp"
#include "Shader/FrameVariableBuffer.hpp"
#include "Shader/OneFrameVariable.hpp"
#include "Shader/ShaderObject.hpp"
#include "Shader/ShaderProgram.hpp"

#include <GlslSource.hpp>

using namespace Castor;

namespace Castor3D
{
	namespace
	{
		uint64_t MakeKey( uint16_t p_textureFlags, uint16_t p_programFlags, uint8_t p_sceneFlags, bool p_invertNormals )
		{
			return ( uint64_t( p_textureFlags ) << 48 )
				   | ( uint64_t( p_programFlags ) << 40 )
				   | ( uint64_t( p_sceneFlags ) << 32 )
				   | ( uint64_t( p_invertNormals ? 0x01 : 0x00 ) );
		}
	}

	ShaderProgramCache::ShaderProgramCache( Engine & p_engine )
		: OwnedBy< Engine >( p_engine )
	{
	}

	ShaderProgramCache::~ShaderProgramCache()
	{
	}

	void ShaderProgramCache::Cleanup()
	{
		for ( auto l_program : m_arrayPrograms )
		{
			GetEngine()->PostEvent( MakeCleanupEvent( *l_program ) );
		}
	}

	void ShaderProgramCache::Clear()
	{
		m_mapBillboards.clear();
		m_mapAutogenerated.clear();
		m_arrayPrograms.clear();
	}

	ShaderProgramSPtr ShaderProgramCache::GetNewProgram( bool p_initialise )
	{
		ShaderProgramSPtr l_return = GetEngine()->GetRenderSystem()->CreateShaderProgram();

		if ( l_return )
		{
			DoAddProgram( l_return, p_initialise );
		}

		return l_return;
	}

	ShaderProgramSPtr ShaderProgramCache::GetAutomaticProgram( RenderPass const & p_renderPass, uint16_t p_textureFlags, uint16_t p_programFlags, uint8_t p_sceneFlags, bool p_invertNormals )
	{
		ShaderProgramSPtr l_return;

		if ( CheckFlag( p_programFlags, ProgramFlag::eBillboards ) )
		{
			uint64_t l_key = MakeKey( p_textureFlags, p_programFlags, p_sceneFlags, false );
			auto const & l_it = m_mapBillboards.find( l_key );

			if ( l_it != m_mapBillboards.end() )
			{
				l_return = l_it->second.lock();
			}
			else
			{
				l_return = DoCreateBillboardProgram( BillboardRenderingType::eInstantiation, p_renderPass, p_textureFlags, p_programFlags, p_sceneFlags );

				if ( l_return )
				{
					DoAddBillboardProgram( l_return, p_textureFlags, p_programFlags, p_sceneFlags );
				}
			}
		}
		else
		{
			uint64_t l_key = MakeKey( p_textureFlags, p_programFlags, p_sceneFlags, p_invertNormals );
			ShaderProgramWPtrUInt64MapConstIt l_it = m_mapAutogenerated.find( l_key );

			if ( l_it != m_mapAutogenerated.end() )
			{
				l_return = l_it->second.lock();
			}
			else
			{
				l_return = DoCreateAutomaticProgram( p_renderPass, p_textureFlags, p_programFlags, p_sceneFlags, p_invertNormals );

				if ( l_return )
				{
					DoAddAutomaticProgram( l_return, p_textureFlags, p_programFlags, p_sceneFlags, p_invertNormals );
				}
			}
		}

		return l_return;
	}

	FrameVariableBuffer & ShaderProgramCache::CreateMatrixBuffer( ShaderProgram & p_shader, uint16_t p_programFlags, uint32_t p_shaderMask )const
	{
		auto & l_buffer = p_shader.CreateFrameVariableBuffer( ShaderProgram::BufferMatrix, p_shaderMask );
		l_buffer.CreateVariable( FrameVariableType::eMat4x4r, Pipeline::MtxProjection, 1 );
		l_buffer.CreateVariable( FrameVariableType::eMat4x4r, Pipeline::MtxModel, 1 );
		l_buffer.CreateVariable( FrameVariableType::eMat4x4r, Pipeline::MtxView, 1 );
		l_buffer.CreateVariable( FrameVariableType::eMat4x4r, Pipeline::MtxNormal, 1 );

		for ( uint32_t i = 0; i < C3D_MAX_TEXTURE_MATRICES; ++i )
		{
			l_buffer.CreateVariable( FrameVariableType::eMat4x4r, Pipeline::MtxTexture[i], 1 );
		}

		return l_buffer;
	}

	FrameVariableBuffer & ShaderProgramCache::CreateSceneBuffer( ShaderProgram & p_shader, uint16_t p_programFlags, uint32_t p_shaderMask )const
	{
		auto & l_buffer = p_shader.CreateFrameVariableBuffer( ShaderProgram::BufferScene, p_shaderMask );
		l_buffer.CreateVariable( FrameVariableType::eVec4f, ShaderProgram::AmbientLight, 1 );
		l_buffer.CreateVariable( FrameVariableType::eVec4f, ShaderProgram::BackgroundColour, 1 );
		l_buffer.CreateVariable( FrameVariableType::eVec4i, ShaderProgram::LightsCount, 1 );
		l_buffer.CreateVariable( FrameVariableType::eVec3r, ShaderProgram::CameraPos, 1 );
		l_buffer.CreateVariable( FrameVariableType::eInt, ShaderProgram::FogType, 1 );
		l_buffer.CreateVariable( FrameVariableType::eFloat, ShaderProgram::FogDensity, 1 );

		return l_buffer;
	}

	FrameVariableBuffer & ShaderProgramCache::CreatePassBuffer( ShaderProgram & p_shader, uint16_t p_programFlags, uint32_t p_shaderMask )const
	{
		auto & l_buffer = p_shader.CreateFrameVariableBuffer( ShaderProgram::BufferPass, p_shaderMask );
		l_buffer.CreateVariable( FrameVariableType::eVec4f, ShaderProgram::MatAmbient, 1 );
		l_buffer.CreateVariable( FrameVariableType::eVec4f, ShaderProgram::MatDiffuse, 1 );
		l_buffer.CreateVariable( FrameVariableType::eVec4f, ShaderProgram::MatEmissive, 1 );
		l_buffer.CreateVariable( FrameVariableType::eVec4f, ShaderProgram::MatSpecular, 1 );
		l_buffer.CreateVariable( FrameVariableType::eFloat, ShaderProgram::MatShininess, 1 );
		l_buffer.CreateVariable( FrameVariableType::eFloat, ShaderProgram::MatOpacity, 1 );
		return l_buffer;
	}

	FrameVariableBuffer & ShaderProgramCache::CreateAnimationBuffer( ShaderProgram & p_shader, uint16_t p_programFlags, uint32_t p_shaderMask )const
	{
		REQUIRE( CheckFlag( p_programFlags, ProgramFlag::eSkinning ) || CheckFlag( p_programFlags, ProgramFlag::eMorphing ) );
		auto & l_buffer = p_shader.CreateFrameVariableBuffer( ShaderProgram::BufferAnimation, p_shaderMask );

		if ( CheckFlag( p_programFlags, ProgramFlag::eSkinning ) )
		{
			l_buffer.CreateVariable( FrameVariableType::eMat4x4r, ShaderProgram::Bones, 400 );
		}

		if ( CheckFlag( p_programFlags, ProgramFlag::eMorphing ) )
		{
			l_buffer.CreateVariable( FrameVariableType::eFloat, ShaderProgram::Time );
		}

		return l_buffer;
	}

	void ShaderProgramCache::CreateTextureVariables( ShaderProgram & p_shader, uint16_t p_textureFlags )const
	{
		p_shader.CreateFrameVariable< OneIntFrameVariable >( ShaderProgram::Lights, ShaderType::ePixel );

		if ( CheckFlag( p_textureFlags, TextureChannel::eAmbient ) )
		{
			p_shader.CreateFrameVariable< OneIntFrameVariable >( ShaderProgram::MapAmbient, ShaderType::ePixel );
		}

		if ( CheckFlag( p_textureFlags, TextureChannel::eColour ) )
		{
			p_shader.CreateFrameVariable< OneIntFrameVariable >( ShaderProgram::MapColour, ShaderType::ePixel );
		}

		if ( CheckFlag( p_textureFlags, TextureChannel::eDiffuse ) )
		{
			p_shader.CreateFrameVariable< OneIntFrameVariable >( ShaderProgram::MapDiffuse, ShaderType::ePixel );
		}

		if ( CheckFlag( p_textureFlags, TextureChannel::eNormal ) )
		{
			p_shader.CreateFrameVariable< OneIntFrameVariable >( ShaderProgram::MapNormal, ShaderType::ePixel );
		}

		if ( CheckFlag( p_textureFlags, TextureChannel::eSpecular ) )
		{
			p_shader.CreateFrameVariable< OneIntFrameVariable >( ShaderProgram::MapSpecular, ShaderType::ePixel );
		}

		if ( CheckFlag( p_textureFlags, TextureChannel::eEmissive ) )
		{
			p_shader.CreateFrameVariable< OneIntFrameVariable >( ShaderProgram::MapEmissive, ShaderType::ePixel );
		}

		if ( CheckFlag( p_textureFlags, TextureChannel::eOpacity ) )
		{
			p_shader.CreateFrameVariable< OneIntFrameVariable >( ShaderProgram::MapOpacity, ShaderType::ePixel );
		}

		if ( CheckFlag( p_textureFlags, TextureChannel::eGloss ) )
		{
			p_shader.CreateFrameVariable< OneIntFrameVariable >( ShaderProgram::MapGloss, ShaderType::ePixel );
		}

		if ( CheckFlag( p_textureFlags, TextureChannel::eHeight ) )
		{
			p_shader.CreateFrameVariable< OneIntFrameVariable >( ShaderProgram::MapHeight, ShaderType::ePixel );
		}
	}

	void ShaderProgramCache::DoAddProgram( ShaderProgramSPtr p_program, bool p_initialise )
	{
		m_arrayPrograms.push_back( p_program );

		if ( p_initialise )
		{
			if ( GetEngine()->GetRenderSystem()->GetCurrentContext() )
			{
				p_program->Initialise();
			}
			else
			{
				GetEngine()->PostEvent( MakeInitialiseEvent( *p_program ) );
			}
		}
	}

	ShaderProgramSPtr ShaderProgramCache::DoCreateAutomaticProgram( RenderPass const & p_renderPass, uint16_t p_textureFlags, uint16_t p_programFlags, uint8_t p_sceneFlags, bool p_invertNormals )const
	{
		ShaderProgramSPtr l_return = GetEngine()->GetRenderSystem()->CreateShaderProgram();

		if ( l_return )
		{
			auto l_matrixUboShaderMask = MASK_SHADER_TYPE_VERTEX | MASK_SHADER_TYPE_PIXEL;
			ShaderModel l_model = GetEngine()->GetRenderSystem()->GetGpuInformations().GetMaxShaderModel();
			l_return->SetSource( ShaderType::eVertex, l_model, p_renderPass.GetVertexShaderSource( p_textureFlags, p_programFlags, p_sceneFlags, p_invertNormals ) );
			l_return->SetSource( ShaderType::ePixel, l_model, p_renderPass.GetPixelShaderSource( p_textureFlags, p_programFlags, p_sceneFlags ) );
			auto l_geometry = p_renderPass.GetGeometryShaderSource( p_textureFlags, p_programFlags, p_sceneFlags );

			if ( !l_geometry.empty() )
			{
				AddFlag( l_matrixUboShaderMask, MASK_SHADER_TYPE_GEOMETRY );
				l_return->CreateObject( ShaderType::eGeometry );
				l_return->SetSource( ShaderType::eGeometry, l_model, l_geometry );
			}

			CreateTextureVariables( *l_return, p_textureFlags );
			CreateMatrixBuffer( *l_return, p_programFlags, l_matrixUboShaderMask );
			CreateSceneBuffer( *l_return, p_programFlags, MASK_SHADER_TYPE_PIXEL );
			CreatePassBuffer( *l_return, p_programFlags, MASK_SHADER_TYPE_PIXEL );

			if ( CheckFlag( p_programFlags, ProgramFlag::eSkinning )
				 || CheckFlag( p_programFlags, ProgramFlag::eMorphing ) )
			{
				CreateAnimationBuffer( *l_return, p_programFlags, MASK_SHADER_TYPE_VERTEX );
			}
		}

		return l_return;
	}

	void ShaderProgramCache::DoAddAutomaticProgram( ShaderProgramSPtr p_program, uint16_t p_textureFlags, uint16_t p_programFlags, uint8_t p_sceneFlags, bool p_invertNormals )
	{
		uint64_t l_key = MakeKey( p_textureFlags, p_programFlags, p_sceneFlags, p_invertNormals );
		auto const & l_it = m_mapAutogenerated.find( l_key );

		if ( l_it == m_mapAutogenerated.end() )
		{
			m_mapAutogenerated.insert( { l_key, p_program } );
			DoAddProgram( p_program, true );
		}
	}

	ShaderProgramSPtr ShaderProgramCache::DoCreateBillboardProgram( BillboardRenderingType p_type, RenderPass const & p_renderPass, uint16_t p_textureFlags, uint16_t p_programFlags, uint8_t p_sceneFlags )const
	{
		ShaderProgramSPtr l_return;

		switch ( p_type )
		{
		case BillboardRenderingType::eInstantiation:
			l_return = DoCreateBillboardInstProgram( p_renderPass, p_textureFlags, p_programFlags, p_sceneFlags );
			break;

		case BillboardRenderingType::eGeometryShader:
			l_return = DoCreateBillboardGSProgram( p_renderPass, p_textureFlags, p_programFlags, p_sceneFlags );
			break;
		}

		return l_return;
	}

	ShaderProgramSPtr ShaderProgramCache::DoCreateBillboardGSProgram( RenderPass const & p_renderPass, uint16_t p_textureFlags, uint16_t p_programFlags, uint8_t p_sceneFlags )const
	{
		auto & l_engine = *GetEngine();
		auto & l_renderSystem = *l_engine.GetRenderSystem();
		Topology l_input = Topology::ePoints;
		Topology l_output = Topology::eTriangleStrips;
		uint32_t l_count = 4;

		ShaderProgramSPtr l_return = GetEngine()->GetRenderSystem()->CreateShaderProgram();

		if ( l_return )
		{
			String l_strVtxShader;
			{
				using namespace GLSL;
				auto l_writer = l_renderSystem.CreateGlslWriter();

				// Shader inputs
				auto position = l_writer.GetAttribute< Vec4 >( ShaderProgram::Position );

				// Shader outputs
				auto gl_Position = l_writer.GetBuiltin< Vec4 >( cuT( "gl_Position" ) );

				l_writer.ImplementFunction< void >( cuT( "main" ), [&]()
				{
					gl_Position = vec4( position.xyz(), 1.0 );
				} );

				l_strVtxShader = l_writer.Finalise();
			}

			String l_strGeoShader;
			{
				using namespace GLSL;
				auto l_writer = l_renderSystem.CreateGlslWriter();

				l_writer.InputGeometryLayout( GetTopologyName( l_input ) );
				l_writer.OutputGeometryLayout( GetTopologyName( l_output ), l_count );

				// Shader inputs
				UBO_MATRIX( l_writer );
				UBO_SCENE( l_writer );
				UBO_BILLBOARD( l_writer );
				auto gl_in = l_writer.GetBuiltin< gl_PerVertex >( cuT( "gl_in" ), 8u );

				// Shader outputs
				auto vtx_worldSpacePosition = l_writer.GetOutput< Vec3 >( cuT( "vtx_worldSpacePosition" ) );
				auto vtx_worldViewSpacePosition = l_writer.GetOutput< Vec3 >( cuT( "vtx_worldViewSpacePosition" ) );
				auto vtx_normal = l_writer.GetOutput< Vec3 >( cuT( "vtx_normal" ) );
				auto vtx_tangent = l_writer.GetOutput< Vec3 >( cuT( "vtx_tangent" ) );
				auto vtx_bitangent = l_writer.GetOutput< Vec3 >( cuT( "vtx_bitangent" ) );
				auto vtx_texture = l_writer.GetOutput< Vec3 >( cuT( "vtx_texture" ) );
				auto gl_Position = l_writer.GetBuiltin< Vec4 >( cuT( "gl_Position" ) );

				l_writer.ImplementFunction< void >( cuT( "main" ), [&]()
				{
					auto l_pos = l_writer.GetLocale( cuT( "l_pos" ), gl_in[0].gl_Position().xyz() );
					auto l_toCamera = l_writer.GetLocale( cuT( "l_toCamera" ), normalize( vec3( c3d_v3CameraPosition.x(), c3d_v3CameraPosition.y(), c3d_v3CameraPosition.z() ) - l_pos ) );
					auto l_up = l_writer.GetLocale( cuT( "l_up" ), vec3( Float( 0 ), 1.0, 0.0 ) );
					auto l_left = l_writer.GetLocale( cuT( "l_left" ), cross( l_toCamera, l_up ) );

					auto l_v3Normal = l_writer.GetLocale( cuT( "l_v3Normal" ), normalize( vec3( l_toCamera.x(), 0.0, l_toCamera.z() ) ) );
					auto l_v3Tangent = l_writer.GetLocale( cuT( "l_v3Tangent" ), l_up );
					auto l_v3Bitangent = l_writer.GetLocale( cuT( "l_v3Bitangent" ), l_left );

					l_left *= c3d_v2iDimensions.x();
					l_up *= c3d_v2iDimensions.y();
					l_writer << Endl();
					{
						l_pos -= ( l_left * Float( 0.5 ) );
						vtx_worldSpacePosition = l_writer.Paren( c3d_mtxModel * vec4( l_pos, 1.0 ) ).xyz();
						vtx_worldViewSpacePosition = l_writer.Paren( c3d_mtxView * vec4( vtx_worldSpacePosition, 1.0 ) ).xyz();
						gl_Position = c3d_mtxProjection * vec4( vtx_worldViewSpacePosition, 1.0 );
						vtx_normal = l_v3Normal;
						vtx_tangent = l_v3Tangent;
						vtx_bitangent = l_v3Bitangent;
						vtx_texture = vec3( Float( 1.0 ), 0.0, 0.0 );
						l_writer.EmitVertex();
					}
					l_writer << Endl();
					{
						l_pos += l_up;
						vtx_worldSpacePosition = l_writer.Paren( c3d_mtxModel * vec4( l_pos, 1.0 ) ).xyz();
						vtx_worldViewSpacePosition = l_writer.Paren( c3d_mtxView * vec4( vtx_worldSpacePosition, 1.0 ) ).xyz();
						gl_Position = c3d_mtxProjection * vec4( vtx_worldViewSpacePosition, 1.0 );
						vtx_normal = l_v3Normal;
						vtx_tangent = l_v3Tangent;
						vtx_bitangent = l_v3Bitangent;
						vtx_texture = vec3( Float( 1.0 ), 1.0, 0.0 );
						l_writer.EmitVertex();
					}
					l_writer << Endl();
					{
						l_pos -= l_up;
						l_pos += l_left;
						vtx_worldSpacePosition = l_writer.Paren( c3d_mtxModel * vec4( l_pos, 1.0 ) ).xyz();
						vtx_worldViewSpacePosition = l_writer.Paren( c3d_mtxView * vec4( vtx_worldSpacePosition, 1.0 ) ).xyz();
						gl_Position = c3d_mtxProjection * vec4( vtx_worldViewSpacePosition, 1.0 );
						vtx_normal = l_v3Normal;
						vtx_tangent = l_v3Tangent;
						vtx_bitangent = l_v3Bitangent;
						vtx_texture = vec3( Float( 0.0 ), 0.0, 0.0 );
						l_writer.EmitVertex();
					}
					l_writer << Endl();
					{
						l_pos += l_up;
						vtx_worldSpacePosition = l_writer.Paren( c3d_mtxModel * vec4( l_pos, 1.0 ) ).xyz();
						vtx_worldViewSpacePosition = l_writer.Paren( c3d_mtxView * vec4( vtx_worldSpacePosition, 1.0 ) ).xyz();
						gl_Position = c3d_mtxProjection * vec4( vtx_worldViewSpacePosition, 1.0 );
						vtx_normal = l_v3Normal;
						vtx_tangent = l_v3Tangent;
						vtx_bitangent = l_v3Bitangent;
						vtx_texture = vec3( Float( 0.0 ), 1.0, 0.0 );
						l_writer.EmitVertex();
					}
					l_writer << Endl();
					l_writer.EndPrimitive();
				} );

				l_strGeoShader = l_writer.Finalise();
			}

			String l_strPxlShader = p_renderPass.GetPixelShaderSource( p_textureFlags, p_programFlags, p_sceneFlags );

			ShaderObjectSPtr l_object = l_return->CreateObject( ShaderType::eGeometry );
			l_object->SetInputType( l_input );
			l_object->SetOutputType( l_output );
			l_object->SetOutputVtxCount( l_count );

			auto l_model = l_renderSystem.GetGpuInformations().GetMaxShaderModel();
			l_return->SetSource( ShaderType::eVertex, l_model, l_strVtxShader );
			l_return->SetSource( ShaderType::eGeometry, l_model, l_strGeoShader );
			l_return->SetSource( ShaderType::ePixel, l_model, l_strPxlShader );

			CreateMatrixBuffer( *l_return, p_programFlags, MASK_SHADER_TYPE_GEOMETRY | MASK_SHADER_TYPE_PIXEL );
			CreateSceneBuffer( *l_return, p_programFlags, MASK_SHADER_TYPE_VERTEX | MASK_SHADER_TYPE_GEOMETRY | MASK_SHADER_TYPE_PIXEL );
			CreatePassBuffer( *l_return, p_programFlags, MASK_SHADER_TYPE_PIXEL );
			CreateTextureVariables( *l_return, p_textureFlags );
			auto & l_billboardUbo = l_return->CreateFrameVariableBuffer( ShaderProgram::BufferBillboards, MASK_SHADER_TYPE_GEOMETRY );
			l_billboardUbo.CreateVariable< Point2iFrameVariable >( ShaderProgram::Dimensions );
		}

		return l_return;
	}

	ShaderProgramSPtr ShaderProgramCache::DoCreateBillboardInstProgram( RenderPass const & p_renderPass, uint16_t p_textureFlags, uint16_t p_programFlags, uint8_t p_sceneFlags )const
	{
		auto & l_engine = *GetEngine();
		auto & l_renderSystem = *l_engine.GetRenderSystem();
		ShaderProgramSPtr l_return = GetEngine()->GetRenderSystem()->CreateShaderProgram();

		if ( l_return )
		{
			String l_strVtxShader;
			{
				using namespace GLSL;
				auto l_writer = l_renderSystem.CreateGlslWriter();

				// Shader inputs
				auto position = l_writer.GetAttribute< Vec4 >( ShaderProgram::Position );
				auto center = l_writer.GetAttribute< Vec3 >( cuT( "center" ) );
				UBO_MATRIX( l_writer );
				UBO_SCENE( l_writer );
				UBO_BILLBOARD( l_writer );

				// Shader outputs
				auto vtx_worldSpacePosition = l_writer.GetOutput< Vec3 >( cuT( "vtx_worldSpacePosition" ) );
				auto vtx_worldViewSpacePosition = l_writer.GetOutput< Vec3 >( cuT( "vtx_worldViewSpacePosition" ) );
				auto vtx_normal = l_writer.GetOutput< Vec3 >( cuT( "vtx_normal" ) );
				auto vtx_tangent = l_writer.GetOutput< Vec3 >( cuT( "vtx_tangent" ) );
				auto vtx_bitangent = l_writer.GetOutput< Vec3 >( cuT( "vtx_bitangent" ) );
				auto vtx_texture = l_writer.GetOutput< Vec3 >( cuT( "vtx_texture" ) );
				auto gl_Position = l_writer.GetBuiltin< Vec4 >( cuT( "gl_Position" ) );

				l_writer.ImplementFunction< void >( cuT( "main" ), [&]()
				{
					auto l_pos = l_writer.GetLocale( cuT( "l_pos" ), position.xyz() );
					auto l_toCamera = l_writer.GetLocale( cuT( "l_toCamera" ), normalize( vec3( c3d_v3CameraPosition.x(), c3d_v3CameraPosition.y(), c3d_v3CameraPosition.z() ) - l_pos ) );
					auto l_up = l_writer.GetLocale( cuT( "l_up" ), vec3( Float( 0 ), 1.0, 0.0 ) );
					auto l_left = l_writer.GetLocale( cuT( "l_left" ), cross( l_toCamera, l_up ) );

					auto l_v3Normal = l_writer.GetLocale( cuT( "l_v3Normal" ), normalize( vec3( l_toCamera.x(), 0.0, l_toCamera.z() ) ) );
					auto l_v3Tangent = l_writer.GetLocale( cuT( "l_v3Tangent" ), l_up );
					auto l_v3Bitangent = l_writer.GetLocale( cuT( "l_v3Bitangent" ), l_left );

					l_pos += center;
					vtx_worldSpacePosition = l_writer.Paren( c3d_mtxModel * vec4( l_pos, 1.0 ) ).xyz();
					vtx_worldViewSpacePosition = l_writer.Paren( c3d_mtxView * vec4( vtx_worldSpacePosition, 1.0 ) ).xyz();
					gl_Position = c3d_mtxProjection * vec4( vtx_worldViewSpacePosition, 1.0 );
					vtx_normal = l_v3Normal;
					vtx_tangent = l_v3Tangent;
					vtx_bitangent = l_v3Bitangent;
					gl_Position = vec4( position.xyz(), 1.0 );
				} );

				l_strVtxShader = l_writer.Finalise();
			}

			String l_strPxlShader = p_renderPass.GetPixelShaderSource( p_textureFlags, p_programFlags, p_sceneFlags );

			auto l_model = l_renderSystem.GetGpuInformations().GetMaxShaderModel();
			l_return->SetSource( ShaderType::eVertex, l_model, l_strVtxShader );
			l_return->SetSource( ShaderType::ePixel, l_model, l_strPxlShader );

			CreateMatrixBuffer( *l_return, p_programFlags, MASK_SHADER_TYPE_PIXEL );
			CreateSceneBuffer( *l_return, p_programFlags, MASK_SHADER_TYPE_VERTEX | MASK_SHADER_TYPE_PIXEL );
			CreatePassBuffer( *l_return, p_programFlags, MASK_SHADER_TYPE_PIXEL );
			CreateTextureVariables( *l_return, p_textureFlags );
			auto & l_billboardUbo = l_return->CreateFrameVariableBuffer( ShaderProgram::BufferBillboards, MASK_SHADER_TYPE_VERTEX );
			l_billboardUbo.CreateVariable< Point2iFrameVariable >( ShaderProgram::Dimensions );
		}

		return l_return;
	}

	void ShaderProgramCache::DoAddBillboardProgram( ShaderProgramSPtr p_program, uint16_t p_textureFlags, uint16_t p_programFlags, uint8_t p_sceneFlags )
	{
		uint64_t l_key = MakeKey( p_textureFlags, p_programFlags, p_sceneFlags, false );
		auto const & l_it = m_mapBillboards.find( l_key );

		if ( l_it == m_mapBillboards.end() )
		{
			m_mapBillboards.insert( { l_key, p_program } );
			DoAddProgram( p_program, true );
		}
	}
}
